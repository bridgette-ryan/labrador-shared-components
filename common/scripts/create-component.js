#!/usr/bin/env node

/* Note: This file was generated by AI tools, not by the author of this repository. */

const readline = require("readline");
const path = require("path");
const fs = require("fs");

function findGitRoot(startPath) {
  let currentPath = startPath;
  while (currentPath !== path.parse(currentPath).root) {
    if (fs.existsSync(path.join(currentPath, ".git"))) {
      return currentPath;
    }
    currentPath = path.dirname(currentPath);
  }
  return null;
}

// Define the menu options
const options = ["Layout", "Atom", "Molecule", "Organism"];
let selectedIndex = 0;
let selectedComponent = "";
let name = "";

// Function to render the menu
function renderMenu() {
  console.clear();
  console.log("What type of component are you creating?:\n");
  console.log("Use arrow keys to navigate, Enter to select:\n");

  options.forEach((option, index) => {
    if (index === selectedIndex) {
      console.log(`> ${option}`);
    } else {
      console.log(`  ${option}`);
    }
  });
}

// Function to handle component type selection
function handleComponentSelection() {
  return new Promise((resolve) => {
    readline.emitKeypressEvents(process.stdin);
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(true);
    }

    renderMenu();

    process.stdin.on("keypress", function onKeypress(str, key) {
      if (key.name === "up" && selectedIndex > 0) {
        selectedIndex--;
        renderMenu();
      } else if (key.name === "down" && selectedIndex < options.length - 1) {
        selectedIndex++;
        renderMenu();
      } else if (key.name === "return") {
        selectedComponent = options[selectedIndex].toLowerCase();
        process.stdin.removeListener("keypress", onKeypress);
        if (process.stdin.isTTY) {
          process.stdin.setRawMode(false);
        }
        resolve();
      } else if (key.ctrl && key.name === "c") {
        process.exit();
      }
    });
  });
}

// Function to ask for component name
function askForName(rl) {
  return new Promise((resolve) => {
    rl.question(
      "Enter the name of the component (only lowercase letters and hyphens allowed): ",
      (answer) => {
        // Convert to lowercase, replace spaces with hyphens, remove any character that's not a-z or hyphen
        name = answer
          .toLowerCase()
          .replace(/\s+/g, "-")
          .replace(/[^a-z-]/g, "");

        // Remove any leading or trailing hyphens
        name = name.replace(/^-+|-+$/g, "");

        // If the name is empty after filtering, ask again
        if (name === "") {
          console.log(
            "Invalid input. Please use only lowercase letters and hyphens."
          );
          return askForName(rl).then(resolve);
        }

        console.log(`Component name formatted to: ${name}`);
        resolve();
      }
    );
  });
}

function toPascalCase(str) {
  return str
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}

function renameFile(oldPath, newPath) {
  if (fs.existsSync(oldPath)) {
    fs.renameSync(oldPath, newPath);
    console.log(`Renamed ${oldPath} to ${newPath}`);
  } else {
    console.log(`File not found: ${oldPath}`);
  }
}

// Function to copy directory contents recursively and perform additional modifications
function copyAndModifyDir(src, dest, componentName) {
  fs.mkdirSync(dest, { recursive: true });
  let entries = fs.readdirSync(src, { withFileTypes: true });

  for (let entry of entries) {
    let srcPath = path.join(src, entry.name);
    let destPath = path.join(dest, entry.name);

    // Skip .rush and node_modules directories
    if (
      entry.isDirectory() &&
      (entry.name === ".rush" || entry.name === "node_modules")
    ) {
      console.log(`Skipping directory: ${entry.name}`);
      continue;
    }

    if (entry.isDirectory()) {
      copyAndModifyDir(srcPath, destPath, componentName);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }

  // After copying, perform the additional steps
  const pascalCaseName = toPascalCase(componentName);

  // 1. Rename Base typescript files to the PascalCase component name
  // Rename the main component file
  const oldComponentPath = path.join(dest, "src", "ComponentBase.tsx");
  const newComponentPath = path.join(dest, "src", `${pascalCaseName}.tsx`);
  renameFile(oldComponentPath, newComponentPath);

  // Rename the test file
  const oldTestPath = path.join(dest, "src", "__tests__", "ComponentBase.test.tsx");
  const newTestPath = path.join(
    dest,
    "src",
    "__tests__",
    `${pascalCaseName}.test.tsx`
  );
  renameFile(oldTestPath, newTestPath);

  // Rename the types file
  const oldTypesPath = path.join(dest, "src", "types", "ComponentBase.types.ts");
  const newTypesPath = path.join(
    dest,
    "src",
    "types",
    `${pascalCaseName}.types.ts`
  );
  renameFile(oldTypesPath, newTypesPath);

  // 2. Update package.json
  const packageJsonPath = path.join(dest, "package.json");
  if (fs.existsSync(packageJsonPath)) {
    let packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
    packageJson.name = `@labrador-sgd/${componentName}`;  // Make sure to change this
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
  }

  // 3. Replace 'Base' with PascalCase name in renamed file and index.ts
  const filesToUpdate = [newComponentPath, path.join(dest, "src", "index.ts")];
  filesToUpdate.forEach((filePath) => {
    if (fs.existsSync(filePath)) {
      let content = fs.readFileSync(filePath, "utf8");
      content = content.replace(/ComponentBase/g, pascalCaseName);
      fs.writeFileSync(filePath, content);
    }
  });
}

// Function to confirm selection
function confirmSelection(rl) {
  return new Promise((resolve) => {
    rl.question(
      `You want to create a ${selectedComponent} named ${name}, correct? (yes/no): `,
      (answer) => {
        resolve(answer.toLowerCase().trim() === "yes");
      }
    );
  });
}

function askStartOverOrQuit(rl) {
  return new Promise((resolve) => {
    rl.question(
      "Do you want to start over? (yes/no, no will quit the program): ",
      (answer) => {
        resolve(answer.toLowerCase().trim() === "yes");
      }
    );
  });
}

// Main function to run the script
async function main() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  const gitRoot = findGitRoot(__dirname);

  if (gitRoot === null) {
    console.error("Error: Not in a Git repository");
    process.exit(1);
  }

  while (true) {
    // Handle component type selection
    await handleComponentSelection();

    console.clear();

    // Ask for component name
    await askForName(rl);

    // Confirm selection
    const confirmed = await confirmSelection(rl);

    if (confirmed) {
      console.log("Moving to the next part of the script...");

      // Check if the directory already exists
      const dirPath = path.join(
        gitRoot,
        "src",
        selectedComponent + "s",
        name.toLowerCase()
      );

      if (fs.existsSync(dirPath)) {
        console.log(`Warning: The directory ${dirPath} already exists.`);
        const startOver = await askStartOverOrQuit(rl);

        if (startOver) {
          console.log("Starting over...");
          selectedIndex = 0;
          selectedComponent = "";
          name = "";
          continue;
        } else {
          console.log("Quitting the program...");
          break;
        }
      } else {
        console.log(`Directory will be created at: ${dirPath}`);
        fs.mkdirSync(dirPath, { recursive: true });

        const baseDir = path.join(gitRoot, "src", "base");

        if (fs.existsSync(baseDir)) {
          console.log(`Copying base files from ${baseDir} to ${dirPath}`);
          try {
            copyAndModifyDir(baseDir, dirPath, name);
            console.log("Base files copied successfully.");
          } catch (error) {
            console.error("Error copying base files:", error);
          }
        } else {
          console.log(
            `Base directory ${baseDir} does not exist. Skipping file copy.`
          );
        }

        console.log(`Component has been created in: ${dirPath}`);
        // Add any additional steps here if needed

        break;
      }
    } else {
      console.log("Let's start over...");
      selectedIndex = 0;
      selectedComponent = "";
      name = "";
    }
  }

  rl.close();
  process.exit();
}

main();
